# 2022.01.17

## Java 기초

- 컴퓨터 기초

  - x86 : 옛날에 컴퓨터(인텔)은 cpu명이 286 386 .. 등으로 나왔따
  - 팬티엄 2? 부터 32bit(4byte)를 기본, 애초에 ip도 4바이트
  - 그래서 x86 ~ 써있으면 대충 32bit, 나중에 x64

- 1KB => 1024Byte

- 1 MB => 1024KB

- 1 GB => 1024MB  

  - 따라서 램 4Gb => 4,294,967,296 바이트  == 2^32, 즉 32비트 체제의 한계는 렘 4기가
  - *** 주소는 1씩 증가할때마다 1byte, 데이터는 1씩 증가할때마다 1bit 증가***

  

- 잡지식
  - 1G : 아날로그 통화
  - 2G : 문자
  - 3G : 영상통화
  - 4G : IP통신, ALL IP(통화하고 바로끄면 기록이 안 남는데, IP로 지정되면 남아.)

- 키보드
  - 보통 키보드가 7비트(128개 정도 써,) => 그래서 ASCII코드가 나온 것



- String 자료형은 특이하다. 분명 참조형인데 syso가 가능하다...

---

### 입력받는 법(for 알고리즘)

- Scanner

~~~java
// 입력을 받기 위해 입력을 도와줄 객체가 필요
		// ctrl + space + o : import
		Scanner sc = new Scanner(System.in); 
		
		// bool
		boolean flag = sc.nextBoolean();
		// 문자 하나만 불가, 
		// char a = sc.nextChar()????
		
		// 정수형 입력
		byte bnum = sc.nextByte();
		short num = sc.nextShort();
		int age = sc.nextInt();
		long money = sc.nextLong();
		
		// 실수형 입력
		float fnum = sc.nextFloat();
		double dnum = sc.nextDouble();
		
		// 문자열 종류 파악하기
		String name = sc.next();
		
		//문자 하나만을 입력받고싶으면
		char c = sc.next().charAt(0);
		
		System.out.println();
~~~

---

- Java에서 / 기호는 몫이다.
- 그래서 1의 자리수 내림을 한다면, 

~~~java
int a = 27;
age = a / 10 * 10(20대);
age = a - (a % 10)
~~~

- 반올림 쉽게 하려면, 5를 더한 후 내림을 한다(원하는 자릿수)

---

- do - while 문:
  - 조건문에서 쓰이는 변수가 반복문 안에서 결정될때?(여러번 인풋 받고싶어!)

---

- class 이름 바꾸기 
  - 우클릭 - refactor - rename, 나중에 모든걸 다 한번에 바꿀 수 도 있음....

---

- codeup.kr 코드업 기초100제! (C언어 들어가서 JAVA로!)

---

- 3항 연산자(자주 쓴다네!)

~~~java
String message = (sth == 1) ? "해삼" : "멍개";
//반환 type = (조건) ? 참일때 return : 거짓일 때 return;
~~~

# 2022.01.18

- APS 만들어야 할 습관
  - 문제 제대로 읽어 이해하기 
  - (필기구로 끄적끄적) 해야할 일 정리
  - IDE에서 주석 넣으며 정리한 일들 쓰며 할 일 정해서 해보기.

- for문의 종류 : (자료형 변수명 : 반복할 수 있는 것) = (for each 문이라고도 불린다)
  - 이건 값을 수정할 수 없는 단점이 있다ㅣ

---

- 단축 평가
  - 논리합 || 
    - a || b , a가 참이면 b 볼 필요 없다
  - 논리곱 &&
    - a && b , a가 거짓이면 b 볼 필요 없다

- 비트연산자 &, | => 컴퓨터니까 그냥 가능해버림!

---

- 블록 안에서 { int a = 0 ;  명령문} 하면 a는 } 만나면 못 쓰지만, 메모리에는 Garbage Collecter 가 돌아야 사라짐

---

- switch case : break문 없으면, 해당 case 밑에 모든 명령문들 다 실행돼(default 포함!)

---

- Integer.MAX_VALUE => 쓰면 최대, 최소 값 구하기 쉬운 편!

---

- XOR -> 두 개가 같으면 1 다르면 0

# 2022.01.19

cf) 클라우드란? (ex) google drive, dropbox(저장 공간), amazone etc()

- 자원(인프라)을 빌려쓰는 것
- 하나의 큰 저장공간을 나눠서 빌려준다~(매번 ssd 사줄 수 없으니까, '근데 CPU는?')
- 나누는 기술이 가상화라고 부른다. 



# 틀린거

- class를 만들땐, 보통 우클릭 클래스 해서 만들어서 main java파일에서 사용
- 와.. 클래스 자체의 멤버 변수를 선언을 안 해도 일단 실행이 돼., 심지어 변수도 안 정해도
- =>  heap 에 있어서(new 때문에), 아.. 선언 하면 알아서 기본생성자 넣는다!
- 그래서 걍 멤버변수 선언만 돼있으면 설정하지 않아도 .변수로 부를 수 있어!

헐.. 생성자도 함수니까 overloading 가능../

이름 + 매개변수 형태까지가 함수의 이름이라고 생각해 ^^

~~~java
new Class().method(); // 실행 가능?
// 가능!! 변수에 담는 행위는 나중에 쓰려고야. 
// new Class() 자체로 인스턴스!!!!! 메서드 사용 가능
~~~

- 갑자기 생성자 만들면, 빨간줄. 그 이유!? => 생성자 만드는 순간 기본생성자 안 생겨

---

#### 내 질문 : 그럼 int[][]에서, 최종적으로 들어가는 자료형태가 int라는건가요?

int[] [] arr = new arr[] []

int [] [] 자체도 하나의 타입!, 마지막에 들어가는게 int라는 뜻!

arr[] 의 타입은 int [] , 또 주소 반환!:  -> int가 아니다! 

#### HW

- 내가만든 array.toString()하면, ? 뭘 toString할건데?
- Array.toString(내가만든배열)이 맞다



## 배열이란? : []

- 같은 타입의 변수의 모임 (같은  타입의 자료를 연속적으로 모아둔 것)

  - 장점 1 :  간편하게 많은 **같은 타입**의 변수를 생성
  - 장점 2 : 연속된 공간을 할당받음

  ​    ( int num = 0; int num= 1 (메모리상에 이곳저곳 생겨짐))

  ​	( 만약 27번지\[칸 \] 31번지 \[칸\] 왜 +4 -> int-4byte니까) , 27번지 + int (27 + 0*4)

  - 장점 3 : "반복문"과의 시너지, 데이터를 인덱스(숫자)로 접근이 가능
  
- 한 번 생성된 배열은 크기 바꿀 수 없음

- **배열의 유형은 모든것이 가능하다** ( 기초자료 8개 + String + int[] +참조형 ,,,,,,)

  - 배열의 인덱스는 0부터
  - 배열크기 : 배열이름.length
  - 마지막 요소 인덱스 : array.length - 1


---

### new => 이거 교수님이 미친듯이 강조하심

~~~java
            int[] num = new int[78]; // 78명의 점수를 담기위한 배열
// 2.num에 주소를 담아  <-  1.공간(int 78개 담아)을 만들고 new에서 주소를 반환해
~~~

- 크기가 정해지지 않아도 괜찮은 데이터를 위한 공간(메모리) 만듦
- new로 만든 공간 -> 이름을 지어줄 수 없음
- 그래서 크기가 정해지지 않은 공간의 위치를 기억한다.
- 그 위치를 기억하기 위해 만든 변수같은 느낌이 int[] ( 이것도 하나의 타입)
- 여기서 위치란 int[78], 즉 배열의 시작점의 주소다.
  - int[] -> **int 배열**의 주소를 담을 수 있음(type)
  - int -> 정수 하나를 담을 수 있음

---

### 두 공간 바꾸기(변수값 교환)

- tmp 변수 만들어서 int tmp = a;
- b = a;
- a = tmp;

- 만약, 최대값 찾고, 공간을 바꿔? -> 계속 반복 ? -> 정렬 가능

---

### for - each : 꺼내서 뭐하고, 꺼내서 뭐하고 - copied value

~~~java
for ( int n : num) {
    // 마치 n = num[0], n = [1], ...
    System.out.println(n);
    // 만약 n을 바꾸면
    n = 123 ; // 이렇게 하면, num 안에있는걸 n에서 복사해서 쓰는거기 떄문에 score 사용 불가
}

// 쉽게  Arrays ctrl + space : 알아서 임포트
 System.out.println( Arrays.toString(num)); // 그냥 문자열만 주는거, 
~~~

### 문자열

- 문자열은 특별취급, new 없어도 됌,
- 상수 메모리라는 공간에 저장
- String type의 기본값 : null, ""는 공백이 아냐!(이상한 실선이 있다고 생각)

---

### 최대값 찾기 -> 굳이 언급한 이유가 있음

만약, 최대값 찾고, 공간을 바꿔? -> 계속 반복 ? -> 정렬 가능

---

### 안 정해진 공간(heap)

- 여기선 초기값 무적권 정해짐, null :  없음

### 이차원 배열

---

- System.arrayCopy
- System.toString

메소드명  . (필요한 것들:파라미터, 전달인자) : 자료형(반환타입) = 주소(패키지명)

함수명

---

### delta ( 상대적인 위치) - APS

int[] dr = {-1, 0, 1, 0} // row

int[] dc = {0, -1, 0,1} // col

 indexOutOfBounds exception을 예방 => 조건문으로!!!

int \[]\[] drc = { {-1,0}, {1,0} ... } 

if dy dx : 어떤게 행이 x인지, 열이 x인지 파악해야함...

---

## 클래스

### 클래스란?

- 다른 타입의 데이터들의 모임(일단 시작은.. 클래스의 일부, 개념잡기)
- 우리가 원하는 형태의 자료를 담기위해(?) 개인화된 도장(특이 int[])

~~~ java
public class Person{   // 도장!
    String na; // 써먹을 수 있어
    int ag;    // 멤버 변수 ; 속성 ; 필드 로 불려! => 그런 속성들이 있다~
    int hei;
    
    //생성자 : 매개변수를 받으면, 알아서 멤버변수에 값을 넣어줌
    Person(String na, int ag, int hei){
        this.na = na;
        this.ag = ag;
        this.hei = hei;
    }
    // 최종적으로 원하는 형태를 마지막으로!
    // 생성자도 함수니, 오버로딩 가능
    Person(){  
        this.Person("kjk", 30, 23); // 다른 생성자를 부를 수도 있어
        System.out.println("Hi")    // 다른 실행문 위에, 가장 처음만
    }
    //
    
    // 메소드(멤버 함수, Behavior)
    void print(){
        System.out.println("사람의 이름은 " + na + "입니다")
    }
}
/* 다른문서 */
Person p = new Person(); // new 이후 : 인스턴스!
p.na = "King";
p.ag = 55;
p.hei = 199;
p.print();
~~~

- \*\* 클래스는 관련있는 함수와 변수를 묶어서 만들어낸 **사용자정의 자료형** \*\*
- 모둔 객체들의 생산처, 객체를 생성하는 틀
- 객체의 상호작용 : (사람 객체 -> 전원 on <- show 화면 스마트폰 객체) 
- 추상화 -> 클래스를 설계

~~~ java
new Class().method(); // 실행 가능?

// 가능!! 변수에 담는 행위는 나중에 쓰려고야. new Class() 자체로 인스턴스!!!!! 메서드 사용 가능
~~~

---

#### 매개변수와 인자

매개변수(Parameter) : 함수를 정의할때 쓰는거 정의 : eat( 매개변수 )

인자(Argument) :                                                   활용 : cat.eat( 인자 )

#### 함수? ..nextInt();

자주 써놓은 명령어들을 묶어서 이름을 붙여놓는것

(이름만 기억하면 돼, 위치를 기억할 필요가 없어, ctrl+f할 필요도 없어)



return : 함수를 호출한 곳에, return 후에 값을 찾아서넣어준다

매개변수의 type을, class형태로 할 수 도 있어!

- 함수도 매번 쓰기 귀찮아 -> Class안에 넣자
  - class안에 변수 있으면, 그냥 쓸 수 있어!
- 이름 + 매개변수 형태까지가 함수의 이름이라고 생각해 ^^



- 매개변수가 있는 함수 ( 생성자 )
  - new Person(a, b, c)

~~~ java
Per(String na, int ag, int hei)
    String na;
	int ag;
	int hei; 랑 같은 의미, 즉 생성자 안에서 새로운 변수를 만들어
        
    그래서 this가 필요하다고!!!!! 객체의 위치에 있는 na를 원하니까
~~~



#### 생성자(함수다)

- 객체가 생성될 떄 최초 한 번 실행되는 **함수**
- 클래스와 함수명이 같아야함.
- **반환 유형**이 없다, 처음 실행할 떄 주소를 넣어줘야하는데, void조차 아니다
- 생성자가 없어> 기본생성자를 컴파일러가 자동으로 만들어줘
- 우클릭 - source - generate constucter;; 생성자 만듬

#### 메서드 오버로딩의 조건

- 메서드 이름 같
- 파라미터 달

생성자에서, String 자료형 2개의 변수가 있따

그걸 만들 떄 cat(String new) == cat (String gender) 컴퓨터는 완전 같다고 인식

#### this( 나 자신의 위치를 만듦)

- 생성된 객체의 주소를 불러줌

- 함수 안(지역변수)의 주소와 객체 안(멤버변수)의 주소는 다르다.

  

클래스 - 도장 - 객체생성 - 함수 - 함수도 클래스에? - 등등등
