# 22/04/03 DB



## 1. DML, DDL 명령어 이해

- **DDL (Data Definition Language)** : 데이터 정의 언어
  - 데이터 베이스 객체(table, view, user, index 등)의 구조를 정의
    - CREATE : 테이블 등 데이터 객체를 생성할 때 사용
    - ALTER : 테이블 등 데이터 객체를 변경할 때 사용
    - DROP : 테이블 등 데이터 객체를 삭제할 떄 사용
    - RENAME : 테이블 등 데이터 객체의 이름을 변경할 때 사용

---

- **DML (Data Manipulation Language)** : 데이터 조작 언어

  - 데이터베이스에서 데이터를 조작하거나 조회할 때 사용

  - 테이블의 **레코드**를 CRUD(Create, Read, Update, Delete)
    - INSERT : 테이블에 새 행을 입력할 때 사용
      - 생성 시 작성한 모든 컬럼에 입력 값이 주어지면 컬럼 이름 생략 가능
      - 컬럼 이름과 입력 값의 순서가 일치하도록 작성(NULL, DEFAULT, AUTO INCREMENT 설정 필드 생략 가능)
    
    ~~~ sql
    INSERT INTO table_name
    VALUES (col_val 1, col_val 2, col_val3, ... ,col_valN),
    (col_val 1, col_val 2, col_val3, ... ,col_valN);
    
    INSERT INTO ss_mamber (userid, username)
    VALUES ('id_kim', '김에스');
    ~~~
    
    - SELECT : 데이터베이스에서 데이터를 조회할 때 사용
    
      - 내용이 많아 아래에~
    
    - UPDATE : 기존 행을 변경할 때 사용
    
      - 기존 레코드를 수정한다
      - **WHERE**절을 이용해 하나의 레코드 또는 다수의 레코드 한 번에 수정 가능
    
      ~~~sql
      UPDATE table_name
      SET col_name = value [,col_name2 = value2, ...]
      [WHERE where_condition];
      ~~~
    
      - WHERE절 생략하면 테이블의 모든 행이 수정돼
    
    - DELETE : 테이블에서 행을 삭제할 때 사용
    
      - 기존 레코드를 삭제한다
      - WHERE절을 이용해 하나의 레코드 또는 다수의 레코드 한 번에 삭제 가능
    
      ~~~sql
      DELETE FROM tbl_name
      [WHERE where_condition];
      ~~~

---

- TCL( Transaction Control Language) : 트렌젝션 제어 언어
  - 트랜잭션단위로 실행한 명령문을 적용하거나 취소
    - COMMIT   : DML문이 변경한 내용을 관리. 변경사항을 저장하거나 취소할 때 사용
    - ROLLBACK : 이 떄, DML 변경 내용은 트랜잭션 단위로 그룹화가 가능하다.

---

## 2. 데이터 베이스 생성 및 사용하기

~~~sql
CREATE DATABASE databasename;
~~~

- CREATE DATABASE 명령문을 새 데이터 베이스를 생성하는데 사용된다
- 데이터 베이스는 여러 테이블을 포함하고 있다
- 데이터 베이스 생성시 관리자 권한으로 생성해야한다.
  - SHOW DATABASES 로 데이터 베이스의 목록 조회 가능

~~~ sql
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name
~~~

- 데이터베이스의 모든 테이블을 삭제하고 데이터베이스르 삭제
- 삭제 시, DROP DATABASE 권한 필요
- DROP SCHEMA는 DROP DATABASE와 동의어
- IF EXISTS는 DB가 없을 시 발생할 수 있는 에러를 방지한다

~~~ sql
USE databasename;
~~~

- 데이터베이스가 있는 경우(접근 권한 포함) USE 명령어를 이용하여 사용한다.

---

## 3. 테이블 생성하기(DDL), 제약 조건

~~~ sql
CREATE TABLE table_name(
	column 1 datatype [options],
    column 2 datatype, 
    column 2 datatype ,
    ....
);
~~~

- 자주 사용하는 Options
  - NOT NULL : 
    - 각 행은 해당열의 값을 포함해야 하며, null값은 허용 되지않음
  - DEFAULT : 
    - 값이 전달되지 않을 때 추가되는 기본값 설정
  - AUTO INCREMENT : 
    - 새 레코드가 추가 될 때 마다 필드 값을 자동으로 1 증가시킴
  - PRIMARY KEY :
    -  테이블에서 행을 고유하게 식별하기 위해 사용. PRIMARY KEY 설정이 있는 열은 일반적으로 ID번호이며 AUTO INCREMENT와 같이 사용되는 경우가 많음
  - UNSIGNED : 
    - 숫자인 경우만 해당 되며, 숫자가 0 또는 양수로 제한됨.

---

### 제약 조건

- 컬럼에 저장될 데이터의 조건을 설정
- 제약조건에 위배되는 데이터는 저장 불가
- 테이블 생성시 컬럼에 지정하거나, constraint로 지정 가능(ALTER를 이용하여 설정 가능)

| 제약사항    | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| NOT NULL    | 각 행은 해당열의 값을 포함해야 하며, null값은 허용되지 않음  |
| UNIQUE      | 컬럼에 중복된 값을 저장 할 수 없음, NULL값은 허용            |
| PRIMARY KEY | 기본키, 컬럼에 중복된 값을 저장 할 수 없고, NULL값도 허용하지 않음(NOT NULL + UNIQUE), 주로 레코드를 구분하기 위한 유일한 값을 지정할 떄 사용 |
| FOREIGN KEY | 특정 테이블의 PK 컬럼에 저장되어 있는 값만 저장. '참조키', '외래키' 라고 불림. NULL값 허용, 어떤 컬럼에 어떤 데이터를 참조하는지 반드시 지정 |
| DEFAULT     | 레코드 입력 시 , 해당 열의 값이 입력되지 않으면 넣어줄 값을 지정. |
| CHECK       | 값의 범위나 종류를 지정, MYSQL 8 버전부터 사용 가능. 이전 버전의 경우 제약조건 설정은 가능하나 적용이 안 됨 |

### cf) 테이블 스키마

- 테이블에 저장될 데이터의 구조와 형식
  - ex) 회원의 정보를 저장하기 위한 테이블

~~~ sql
use ssdb;
CREATE TABLE ss_member(
idx			INT				NOT NULL AUTO INCREMENT,
userid		VARCHAR(16)		NOT NULL,
username	VARCHAR(20),
userpw		VARCHAR(16),
emailid		VARCHAR(20),
emaildomain	VARCHAR(50),
joindate	TIMESTAMP		NOT NULL DEFAULT current_timestamp;
PRIMARY KEY (idx)
)ENGINE = InnoDB DEFAULT CHARSET=utf8;
~~~

- DESC 명령어를 이용해서 생성된 테이블 스키마 확인 가능



## 5,6 SELECT - JOIN, GROUP BY

### 기초

~~~ sql
5.SELECT [DISTINCT] {* | column_name | expressions[alias] }
1.FROM table_references
2.[WHERE where_condition]
3.[GROUP BY {col_name | expr | position},]
4.[HAVING where_condition]
6.[ORDER BY{col_name | expr | position} [ASC|DESC]]
7.[LIMIT {[offset,] row_count | row_count OFFSET offset}];

cf) 이렇게 조건을 줄 수 있음
CASE
	WHEN condition1 THEN result1
	WHEN condition2 THEN result2
	ELSE result
END col_name;
~~~

### 집계 함수(Aggregate Function)

- 여러 값의 집합(복수 행)에 대해서 동작한다. (복수 행 함수, 통계 함수, 그룹 함수)
- GROUP BY 절과 함꼐 사용해 전체 집합의 하위 집합을 그룹화한다.
- AVG, COUNT(조회된 행의 수 반환), MAX, MIN, SUM< STD

### 집계 함수 - HAVING 절

- 집계 함수의 결과 내에서 조건문에 맞는 레코드를 조회

~~~ sql
SELECT deptno 부서번호, COUNT(*) 사원수, ROUND(AVG(sal + IFNULL(comm, 0)), 2) "평균급여"
FROM emp
GROUP BY deptno
HAVING AVG(sal + IFNULL(comm, 0)) > 2000;
~~~

---

### 







## 7. 트랜잭션이란?

- 커핏(Commit) 하거나 롤백(Rollback) 할 수 있는 가장 작은 작업 단위
- COMMIT : 트랜잭션을 종료하여 변경 사항(DML)에 대해서 영구적으로 저장하는 SQL
- ROLLBACK : 트랜잭션에 의해 수행된 모든 변경사항을 실행 취소하는 SQL

| name              | description                                                 |
| ----------------- | ----------------------------------------------------------- |
| START TRANSACTION | 트랝잭션을 시작. COMMIT, ROLLBACK이 나오기 전까지 모든 SQL. |
| COMMIT            | 트랜잭션에서 변경한 사항을 영구적으로 DB에 반영             |
| ROLLBACK          | START TRANSACTION 실행 전 상태로 되돌림                     |

~~~SQL
USE database;
CREATE TABLE test_table(
	val VARCHAR(20));
START TRANSACTION;
INSERT INTO test_table VALUES ('A');
INSERT INTO test_table VALUES ('B');
INSERT INTO test_table VALUES ('C');
ROLLBACK;
SELECT * FROM test_table; -- 아무것도 나오지 않는다

START TRANSACTION;
INSERT INTO test_table VALUES ('s');
INSERT INTO test_table VALUES ('i');
INSERT INTO test_table VALUES ('m');
INSERT INTO test_table VALUES ('s');
COMMIT;
SELECT * FROM test_table; -- (sims 나옴)
~~~













